<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RMI基础 | ShaGou's Blog</title><meta name="author" content="ShaGou"><meta name="copyright" content="ShaGou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RMI简述正常的一般情况下java方法调用指的是同一个jvm内方法的调用，RMI 允许一个 Java 虚拟机（JVM）中的对象调用另一个 JVM 中对象的方法，如同调用本地方法 其实也就是服务端将一个远程对象开放出去，客户端可以请求这个服务端，然后使用这个远程对象的方法。 RMI使用socket链接服务端和客户端，每个远程对象对应一个端口，当存在多个远程对象时，就需要一个注册中心来进行管理，客户端">
<meta property="og:type" content="article">
<meta property="og:title" content="RMI基础">
<meta property="og:url" content="http://example.com/2025/03/25/RMI%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="ShaGou's Blog">
<meta property="og:description" content="RMI简述正常的一般情况下java方法调用指的是同一个jvm内方法的调用，RMI 允许一个 Java 虚拟机（JVM）中的对象调用另一个 JVM 中对象的方法，如同调用本地方法 其实也就是服务端将一个远程对象开放出去，客户端可以请求这个服务端，然后使用这个远程对象的方法。 RMI使用socket链接服务端和客户端，每个远程对象对应一个端口，当存在多个远程对象时，就需要一个注册中心来进行管理，客户端">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/touxiang.jpg">
<meta property="article:published_time" content="2025-03-25T12:53:01.000Z">
<meta property="article:modified_time" content="2025-06-25T13:57:07.912Z">
<meta property="article:author" content="ShaGou">
<meta property="article:tag" content="RMI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/touxiang.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "RMI基础",
  "url": "http://example.com/2025/03/25/RMI%E5%9F%BA%E7%A1%80/",
  "image": "http://example.com/img/touxiang.jpg",
  "datePublished": "2025-03-25T12:53:01.000Z",
  "dateModified": "2025-06-25T13:57:07.912Z",
  "author": [
    {
      "@type": "Person",
      "name": "ShaGou",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/03/25/RMI%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RMI基础',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://img.picui.cn/free/2025/03/02/67c43db011f5f.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tag"></i><span> 标签目录</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/index.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ShaGou's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">RMI基础</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tag"></i><span> 标签目录</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">RMI基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-25T12:53:01.000Z" title="发表于 2025-03-25 20:53:01">2025-03-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-25T13:57:07.912Z" title="更新于 2025-06-25 21:57:07">2025-06-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url(/img/index.jpg);"></div><article class="container post-content" id="article-container"><h1 id="RMI简述"><a href="#RMI简述" class="headerlink" title="RMI简述"></a>RMI简述</h1><p>正常的一般情况下java方法调用指的是同一个jvm内方法的调用，RMI 允许一个 Java 虚拟机（JVM）中的对象调用另一个 JVM 中对象的方法，<strong>如同调用本地方法</strong></p>
<p>其实也就是<strong>服务端</strong>将一个远程对象开放出去，<strong>客户端</strong>可以请求这个服务端，然后使用这个远程对象的方法。</p>
<p>RMI使用socket链接服务端和客户端，每个远程对象对应一个端口，当存在多个远程对象时，就需要一个<strong>注册中心</strong>来进行管理，客户端向注册中心询问需要的远程对象的ip和端口来实现远程方法调用。</p>
<p>以下是一张模式图：</p>
<p><img src="D:\Hexo\source_posts\RMI基础\1.png"></p>
<p>来自：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/8760">文章 - JAVA安全基础（四）– RMI机制 - 先知社区</a></p>
<p>这里有俩个重要的概念：</p>
<ol>
<li><p><strong>Stub</strong></p>
<p>Stub由服务端创建，通过动态代理的方式，动态代理远程对象，包含了远程对象及其IP，端口等信息。在客户端访问服务端时，服务端将Stub发送给客户端，客户端利用接受到的Stub中的网络信息与客户端进行通信</p>
</li>
<li><p><strong>Skeleton</strong><br>Skeleton创建于服务端，用来处理由客户端发来的请求</p>
</li>
</ol>
<h2 id="一个简单的RMI实现"><a href="#一个简单的RMI实现" class="headerlink" title="一个简单的RMI实现"></a>一个简单的RMI实现</h2><p>当实现RMI时，客户端和服务端需要创建一个相同的要调用的远程方法的接口，并且继承Remote类同时接口方法要抛出RemoteException异常</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRemoteObj</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="RMIServer"><a href="#RMIServer" class="headerlink" title="RMIServer"></a>RMIServer</h3><p>在RMIServer中对上述的接口进行实现，同时要继承UnicastRemoteObject类</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteObjImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">IRemoteObj</span>{</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RemoteObjImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">        <span class="type">String</span> <span class="variable">upKeywords</span> <span class="operator">=</span> keywords.toUpperCase();</span><br><span class="line">        System.out.println(upKeywords);</span><br><span class="line">        <span class="keyword">return</span> upKeywords;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后创建远程对象，创建注册中心，并且将远程对象绑定到注册中心去</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">RemoteObjImpl</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjImpl</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        registry.bind(<span class="string">"remoteObj"</span>,remoteObj);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="RMIClient"><a href="#RMIClient" class="headerlink" title="RMIClient"></a>RMIClient</h3><p>客户端就比较简单，链接注册中心，获取远程对象，调用远程方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">"127.0.0.1"</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">"remoteObj"</span>);</span><br><span class="line">        remoteObj.sayHello(<span class="string">"hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="1-服务端创建远程服务"><a href="#1-服务端创建远程服务" class="headerlink" title="1.服务端创建远程服务"></a>1.服务端创建远程服务</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RemoteObjImpl</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjImpl</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>我们下断点调试一下，这里第一步来到RemoteObjImpl的构造方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">RemoteObjImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException {}</span><br></pre></td></tr></tbody></table></figure>

<p>由于RemoteObjImpl继承了UnicastRemoteObject，我们继续往下跟。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">	<span class="built_in">this</span>.port = port;</span><br><span class="line">    exportObject((Remote) <span class="built_in">this</span>, port);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里传入了一个0作为port，然后调用了一个 ==exportObject()== </p>
<ul>
<li>这个方法会做以下几件事：</li>
</ul>
<ol>
<li>生成Stub（代理）对象：为你的远程对象生成一个代理（Stub），客户端通过Stub与服务端通信。</li>
<li>监听端口：在指定端口（0表示自动分配）上监听远程调用请求。</li>
<li>注册到RMI运行时：将该对象注册到RMI运行时，使其可以被远程访问。</li>
<li>分配对象ID：为远程对象分配唯一的对象标识。</li>
</ol>
<p>我们继续往下跟</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, <span class="type">int</span> port)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> exportObject(obj, <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(port));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里会创建一个UnicastServerRef()，这个UnicastServerRef就是RMI框架中的一个核心类，主要作用是<strong>管理远程对象的导出</strong>、<strong>监听端口</strong>、<strong>处理远程调用请求</strong>，以下是其构造过程：</p>
<h3 id="UnicastServerRef"><a href="#UnicastServerRef" class="headerlink" title="UnicastServerRef"></a><strong>UnicastServerRef</strong></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastServerRef</span><span class="params">(<span class="type">int</span> port)</span> {</span><br><span class="line">	<span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(port));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里又new了一个LiveRef()</p>
<blockquote>
<p>LiveRef 主要负责：</p>
<ul>
<li>记录远程对象的唯一标识（ObjID）</li>
<li>记录监听的端口号</li>
<li>记录主机地址</li>
<li>管理底层的“传输层”连接</li>
</ul>
</blockquote>
<p>如下是LiveRef的构造过程：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(<span class="type">int</span> port)</span> {</span><br><span class="line">	<span class="built_in">this</span>((<span class="keyword">new</span> <span class="title class_">ObjID</span>()), port);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(ObjID objID, <span class="type">int</span> port)</span> {</span><br><span class="line">	<span class="built_in">this</span>(objID, TCPEndpoint.getLocalEndpoint(port), <span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(ObjID objID, Endpoint endpoint, <span class="type">boolean</span> isLocal)</span> {</span><br><span class="line">	ep = endpoint;</span><br><span class="line">	id = objID;</span><br><span class="line">	<span class="built_in">this</span>.isLocal = isLocal;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的 TCPEndpoint.getLocalEndpoint(port) 为远程对象生成一个“本机IP+端口”的网络身份标识，后续所有RMI通信都要用到它。这里我们就不过多展开了，只需要知道它这里本质就是返回了一个ip+端口。</p>
<p>到这里UnicastServerRef()完成了构造，值得一提的是在 JDK 1.5 之后 UnicastServerRef 里直接包含了 Skeleton 的功能。</p>
<p>我们继续看 exportObject() 方法做了什么</p>
<h3 id="exportObject"><a href="#exportObject" class="headerlink" title="exportObject()"></a>exportObject()</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, UnicastServerRef sref)</span></span><br><span class="line">	<span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// if obj extends UnicastRemoteObject, set its ref.</span></span><br><span class="line">	<span class="keyword">if</span> (obj <span class="keyword">instanceof</span> UnicastRemoteObject) {</span><br><span class="line">	((UnicastRemoteObject) obj).ref = sref;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> sref.exportObject(obj, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里将上面创建好的UnicastServerRef实例传递给sref变量然后调用sref的exportObject()方法，也就是调用UnicastServerRef.exportObject()</p>
<p>这里由于信息较多我们直接使用注释来说明每句代码的作用</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote impl, Object data, <span class="type">boolean</span> permanent)</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//获取远程对象的Class对象，用于后续创建代理和获取方法信息</span></span><br><span class="line">	Class&lt;?&gt; implClass = impl.getClass();</span><br><span class="line">	Remote stub;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//使用动态代理创建Stub对象</span></span><br><span class="line">        <span class="comment">//第一个参数是远程对象的Class对象</span></span><br><span class="line">        <span class="comment">//第二个参数是我们之前创建的liveRef实例，包含了网络请求的功能</span></span><br><span class="line">        <span class="comment">//第三个参数表示是否强制使用Stub</span></span><br><span class="line">		stub = Util.createProxy(implClass, getClientRef(), forceStubUse);</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">//异常检测</span></span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException e) {</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">			<span class="string">"remote object implements illegal remote interface"</span>, e);</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">//创建Skeleton对象，这里关系到注册中心，创建远程服务时不会执行，我们后面再了解</span></span><br><span class="line">	<span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) {</span><br><span class="line">	setSkeleton(impl);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//创建Target对象</span></span><br><span class="line">	<span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line">    <span class="comment">//LiveRef.exportObject()-&gt;TCPEndpoint.exportObject()-&gt;TCPTransport.exportObject()将封装了全部信息的Target导出到网络</span></span><br><span class="line">	ref.exportObject(target);</span><br><span class="line">	hashToMethod_Map = hashToMethod_Maps.get(implClass);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里来解释一下这个target的作用，target对之前创建的实例进行了封装，通过构造方法来看：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Target</span><span class="params">(Remote impl, Dispatcher disp, Remote stub, ObjID id,</span></span><br><span class="line"><span class="params">              <span class="type">boolean</span> permanent)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">this</span>.weakImpl = <span class="keyword">new</span> <span class="title class_">WeakRef</span>(impl, ObjectTable.reapQueue);</span><br><span class="line">    <span class="built_in">this</span>.disp = disp;</span><br><span class="line">    <span class="built_in">this</span>.stub = stub;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.acc = AccessController.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Fix for 4149366: so that downloaded parameter types unmarshalled</span></span><br><span class="line"><span class="comment">     * for this impl will be compatible with types known only to the</span></span><br><span class="line"><span class="comment">     * impl class's class loader (when it's not identical to the</span></span><br><span class="line"><span class="comment">     * exporting thread's context class loader), mark the impl's class</span></span><br><span class="line"><span class="comment">     * loader as the loader to use as the context class loader in the</span></span><br><span class="line"><span class="comment">     * server's dispatch thread while a call to this impl is being</span></span><br><span class="line"><span class="comment">     * processed (unless this exporting thread's context class loader is</span></span><br><span class="line"><span class="comment">     * a child of the impl's class loader, such as when a registry is</span></span><br><span class="line"><span class="comment">     * exported by an application, in which case this thread's context</span></span><br><span class="line"><span class="comment">     * class loader is preferred).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">threadContextLoader</span> <span class="operator">=</span></span><br><span class="line">        Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">serverLoader</span> <span class="operator">=</span> impl.getClass().getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (checkLoaderAncestry(threadContextLoader, serverLoader)) {</span><br><span class="line">        <span class="built_in">this</span>.ccl = threadContextLoader;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">this</span>.ccl = serverLoader;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.permanent = permanent;</span><br><span class="line">    <span class="keyword">if</span> (permanent) {</span><br><span class="line">        pinImpl();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Target存储了远程对象的所有信息，包括远程对象的Class对象，Stub，以及ID等信息。</p>
<p>之后就要真正地将之前创建的所有东西导出到网络，其实也就是将封装了所有内容的Target导出到网络。</p>
<p>这里走了一个LiveRef.exportObject(target)-&gt;TCPEndpoint.exportObject(target)-&gt;TCPTransport.exportObject(target)，我们直接来看最后的TCPTransport.exportObject(target)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">    <span class="comment">//1. 开启网络监听</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">        listen();<span class="comment">//开启网络服务，监听网络请求</span></span><br><span class="line">        exportCount++;<span class="comment">//增加导出计数</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 将Target添加到导出对象表</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//这里实质是将Target存储到ObejctTable对象的一个表中</span></span><br><span class="line">        <span class="built_in">super</span>.exportObject(target);</span><br><span class="line">        ok = <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (!ok) {</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">                <span class="comment">//存储失败就取消计数，也就是发布失败</span></span><br><span class="line">                decrementExportCount();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里走了一个listen()</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">    <span class="keyword">assert</span> Thread.holdsLock(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">TCPEndpoint</span> <span class="variable">ep</span> <span class="operator">=</span> getEndpoint();</span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> ep.getPort();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (tcpLog.isLoggable(Log.BRIEF)) {</span><br><span class="line">            tcpLog.log(Log.BRIEF,</span><br><span class="line">                <span class="string">"(port "</span> + port + <span class="string">") create server socket"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            server = ep.newServerSocket();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Don't retry ServerSocket if creation fails since</span></span><br><span class="line"><span class="comment">             * "port in use" will cause export to hang if an</span></span><br><span class="line"><span class="comment">             * RMIFailureHandler is not installed.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NewThreadAction</span>(<span class="keyword">new</span> <span class="title class_">AcceptLoop</span>(server),</span><br><span class="line">                                    <span class="string">"TCP Accept-"</span> + port, <span class="literal">true</span>));</span><br><span class="line">            t.start();</span><br><span class="line">        } <span class="keyword">catch</span> (java.net.BindException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">"Port already in use: "</span> + port, e);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">"Listen failed on port: "</span> + port, e);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// otherwise verify security access to existing server socket</span></span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) {</span><br><span class="line">            sm.checkListen(port);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到这里创建了一个ServerSocket，同时创建了一个线程来进行网络通信，这里就将远程对象发布出去同时处理网络请求，具体的网络请求逻辑我们就不深究了。</p>
<p>到这里就成功创建了远程服务。总结其流程就是：</p>
<blockquote>
<ol>
<li>调用 RemoteObjImpl 构造函数<br>RemoteObjImpl remoteObj = new RemoteObjImpl();<br>↓</li>
<li>调用父类 UnicastRemoteObject 构造函数<br>super();<br>↓</li>
<li>调用带端口的构造函数<br>this(0);<br>↓</li>
<li>调用 exportObject 方法<br>exportObject((Remote) this, port);<br>↓</li>
<li>创建动态代理（Stub）<br>stub = Util.createProxy(implClass, getClientRef(), forceStubUse);<br>↓</li>
<li>创建 Target 对象<br>Target target = new Target(impl, this, stub, ref.getObjID(), permanent);<br>↓</li>
<li>导出 Target 对象<br>ref.exportObject(target);<br>↓</li>
<li>确保服务器套接字监听<br>listen();<br>↓</li>
<li>注册到对象表<br>super.exportObject(target);<br>↓</li>
<li>完成导出</li>
</ol>
</blockquote>
<p>这里在完成导出后还会执行一步记录的过程，也就是TCPTransport.exportObject(target)中的super.exportObject(target);</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">    target.setExportedTransport(<span class="built_in">this</span>);</span><br><span class="line">    ObjectTable.putTarget(target);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putTarget</span><span class="params">(Target target)</span> <span class="keyword">throws</span> ExportException {</span><br><span class="line">    <span class="type">ObjectEndpoint</span> <span class="variable">oe</span> <span class="operator">=</span> target.getObjectEndpoint();</span><br><span class="line">    <span class="type">WeakRef</span> <span class="variable">weakImpl</span> <span class="operator">=</span> target.getWeakImpl();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DGCImpl.dgcLog.isLoggable(Log.VERBOSE)) {</span><br><span class="line">        DGCImpl.dgcLog.log(Log.VERBOSE, <span class="string">"add object "</span> + oe);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (tableLock) {</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Do nothing if impl has already been collected (see 6597112). Check while</span></span><br><span class="line"><span class="comment">         * holding tableLock to ensure that Reaper cannot process weakImpl in between</span></span><br><span class="line"><span class="comment">         * null check and put/increment effects.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (target.getImpl() != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (objTable.containsKey(oe)) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">                    <span class="string">"internal error: ObjID already in use"</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (implTable.containsKey(weakImpl)) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">"object already exported"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            objTable.put(oe, target);</span><br><span class="line">            implTable.put(weakImpl, target);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!target.isPermanent()) {</span><br><span class="line">                incrementKeepAliveCount();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里objTable.put(oe, target); implTable.put(weakImpl, target);将远程对象的target信息存储起来。到这里全部流程结束</p>
<p>接下来就要进行创建注册中心+绑定</p>
<h2 id="2-服务端创建注册中心-绑定"><a href="#2-服务端创建注册中心-绑定" class="headerlink" title="2. 服务端创建注册中心+绑定"></a>2. 服务端创建注册中心+绑定</h2><h3 id="创建注册中心"><a href="#创建注册中心" class="headerlink" title="创建注册中心"></a>创建注册中心</h3><p>创建注册中心其实和创建远程服务类似，同样是创建注册中心对象，然后将注册中心对象发布到网络，最后返回返回一个创建好的注册中心以供使用</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>跟进去看</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">createRegistry</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryImpl</span>(port);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里先走Registry的构造方法</p>
<p>在创建动态代理时，Java 使用 Instrumentation 机制来转换类，添加网络通信相关的代码，确保生成的代理类符合安全要求，所以会先走下面这样一段代码，这里不是特比想关我们可以不看。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[]</span><br><span class="line">transform(  ClassLoader         loader,</span><br><span class="line">            String              classname,</span><br><span class="line">            Class&lt;?&gt;            classBeingRedefined,</span><br><span class="line">            ProtectionDomain    protectionDomain,</span><br><span class="line">            <span class="type">byte</span>[]              classfileBuffer,</span><br><span class="line">            <span class="type">boolean</span>             isRetransformer) {</span><br><span class="line">    <span class="type">TransformerManager</span> <span class="variable">mgr</span> <span class="operator">=</span> isRetransformer?</span><br><span class="line">                                    mRetransfomableTransformerManager :</span><br><span class="line">                                    mTransformerManager;</span><br><span class="line">    <span class="keyword">if</span> (mgr == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// no manager, no transform</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> mgr.transform(   loader,</span><br><span class="line">                                classname,</span><br><span class="line">                                classBeingRedefined,</span><br><span class="line">                                protectionDomain,</span><br><span class="line">                                classfileBuffer);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>来到 RegistryImpl() 的构造方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RegistryImpl</span><span class="params">(<span class="type">int</span> port)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 1. 检查是否是默认端口且设置了安全管理器（其实就是检查是否是默认的1099端口并且通过了安全检查，如果是就不需要安全检查可以特权创建）</span></span><br><span class="line">    <span class="keyword">if</span> (port == Registry.REGISTRY_PORT &amp;&amp; System.getSecurityManager() != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 2. 使用特权操作创建注册中心</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Void&gt;() {</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">                    <span class="comment">// 3. 创建 LiveRef</span></span><br><span class="line">                    <span class="type">LiveRef</span> <span class="variable">lref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, port);</span><br><span class="line">                    <span class="comment">// 4. 设置服务端引用</span></span><br><span class="line">                    setup(<span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(lref));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                }</span><br><span class="line">            }, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">SocketPermission</span>(<span class="string">"localhost:"</span>+port, <span class="string">"listen,accept"</span>));</span><br><span class="line">        } <span class="keyword">catch</span> (PrivilegedActionException pae) {</span><br><span class="line">            <span class="keyword">throw</span> (RemoteException)pae.getException();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 5. 如果不是默认端口或没有安全管理器，直接创建（使用其他端口或没有通过检查就需要普通创建）</span></span><br><span class="line">        <span class="type">LiveRef</span> <span class="variable">lref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, port);</span><br><span class="line">        setup(<span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(lref));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里我们正常是直接走到5这一步了，使用也就不研究上面的安全检查的内容了。</p>
<p>这里首先先创建了一个LiveRef然后又用UnicastServerRef封装了LiveRef，和创建远程服务处的几乎相同，区别就是这里给出了端口，我们往下看setup()方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">(UnicastServerRef uref)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Server ref must be created and assigned before remote</span></span><br><span class="line"><span class="comment">     * object 'this' can be exported.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ref = uref;</span><br><span class="line">    uref.exportObject(<span class="built_in">this</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里也同创建远程对象时类似，调用了UnicastServerRef.exportObject() 区别是创建远程对象时第三个参数是false，这里的第三个参数是true，所以我们要关注一下这里。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote impl, Object data,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> permanent)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    Class&lt;?&gt; implClass = impl.getClass();</span><br><span class="line">    Remote stub;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        stub = Util.createProxy(implClass, getClientRef(), forceStubUse);</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalArgumentException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">            <span class="string">"remote object implements illegal remote interface"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) {</span><br><span class="line">        setSkeleton(impl);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line">    ref.exportObject(target);</span><br><span class="line">    hashToMethod_Map = hashToMethod_Maps.get(implClass);</span><br><span class="line">    <span class="keyword">return</span> stub;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>第一个区别出现在stub = Util.createProxy(implClass, getClientRef(), forceStubUse);我们进去看</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                 RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">    <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">{</span><br><span class="line">    Class&lt;?&gt; remoteClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        remoteClass = getRemoteClass(implClass);</span><br><span class="line">    } <span class="keyword">catch</span> (ClassNotFoundException ex ) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">            <span class="string">"object does not implement a remote interface: "</span> +</span><br><span class="line">            implClass.getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forceStubUse ||</span><br><span class="line">        !(ignoreStubClasses || !stubClassExists(remoteClass)))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> implClass.getClassLoader();</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] interfaces = getRemoteInterfaces(implClass);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RemoteObjectInvocationHandler</span>(clientRef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* REMIND: private remote interfaces? */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Remote&gt;() {</span><br><span class="line">            <span class="keyword">public</span> Remote <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> (Remote) Proxy.newProxyInstance(loader,</span><br><span class="line">                                                       interfaces,</span><br><span class="line">                                                       handler);</span><br><span class="line">            }});</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalArgumentException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(<span class="string">"unable to create proxy"</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">stubClassExists</span><span class="params">(Class&lt;?&gt; remoteClass)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!withoutStubs.containsKey(remoteClass)) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Class.forName(remoteClass.getName() + <span class="string">"_Stub"</span>,</span><br><span class="line">                          <span class="literal">false</span>,</span><br><span class="line">                          remoteClass.getClassLoader());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException cnfe) {</span><br><span class="line">            withoutStubs.put(remoteClass, <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建远程对象时if (forceStubUse || !(ignoreStubClasses || !stubClassExists(remoteClass)))不满足这个判断的!stubClassExists(remoteClass)条件，所以直接走下面创建了一个动态代理，创建注册中心时是可以满足的，于是走到了createStub(remoteClass, clientRef);里</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RemoteStub <span class="title function_">createStub</span><span class="params">(Class&lt;?&gt; remoteClass, RemoteRef ref)</span></span><br><span class="line">    <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">{</span><br><span class="line">    <span class="type">String</span> <span class="variable">stubname</span> <span class="operator">=</span> remoteClass.getName() + <span class="string">"_Stub"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure to use the local stub loader for the stub classes.</span></span><br><span class="line"><span class="comment">     * When loaded by the local loader the load path can be</span></span><br><span class="line"><span class="comment">     * propagated to remote clients, by the MarshalOutputStream/InStream</span></span><br><span class="line"><span class="comment">     * pickle methods</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Class&lt;?&gt; stubcl =</span><br><span class="line">            Class.forName(stubname, <span class="literal">false</span>, remoteClass.getClassLoader());</span><br><span class="line">        Constructor&lt;?&gt; cons = stubcl.getConstructor(stubConsParamTypes);</span><br><span class="line">        <span class="keyword">return</span> (RemoteStub) cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[] { ref });</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">            <span class="string">"Stub class not found: "</span> + stubname, e);</span><br><span class="line">    } <span class="keyword">catch</span> (NoSuchMethodException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">            <span class="string">"Stub class missing constructor: "</span> + stubname, e);</span><br><span class="line">    } <span class="keyword">catch</span> (InstantiationException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">            <span class="string">"Can't create instance of stub class: "</span> + stubname, e);</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalAccessException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">            <span class="string">"Stub class constructor not public: "</span> + stubname, e);</span><br><span class="line">    } <span class="keyword">catch</span> (InvocationTargetException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">            <span class="string">"Exception creating instance of stub class: "</span> + stubname, e);</span><br><span class="line">    } <span class="keyword">catch</span> (ClassCastException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">            <span class="string">"Stub class not instance of RemoteStub: "</span> + stubname, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里是利用反射创建了一个Stub<br>所以这里的区别就是：对于创建 Stub 创建远程服务时是直接通过动态代理创建的，创建注册中心是通过forname创建的。</p>
<p>继续往下看exportObject()方法</p>
<p>第二个区别是if (stub instanceof RemoteStub)判断这里会通过，会走一步 setSkeleton(impl);</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSkeleton</span><span class="params">(Remote impl)</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">    <span class="keyword">if</span> (!withoutSkeletons.containsKey(impl.getClass())) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            skel = Util.createSkeleton(impl);</span><br><span class="line">        } <span class="keyword">catch</span> (SkeletonNotFoundException e) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Ignore exception for skeleton class not found, because a</span></span><br><span class="line"><span class="comment">             * skeleton class is not necessary with the 1.2 stub protocol.</span></span><br><span class="line"><span class="comment">             * Remember that this impl's class does not have a skeleton</span></span><br><span class="line"><span class="comment">             * class so we don't waste time searching for it again.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            withoutSkeletons.put(impl.getClass(), <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Skeleton <span class="title function_">createSkeleton</span><span class="params">(Remote object)</span></span><br><span class="line">    <span class="keyword">throws</span> SkeletonNotFoundException</span><br><span class="line">{</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        cl = getRemoteClass(object.getClass());</span><br><span class="line">    } <span class="keyword">catch</span> (ClassNotFoundException ex ) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(</span><br><span class="line">            <span class="string">"object does not implement a remote interface: "</span> +</span><br><span class="line">            object.getClass().getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now try to load the skeleton based ont he name of the class</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">skelname</span> <span class="operator">=</span> cl.getName() + <span class="string">"_Skel"</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Class&lt;?&gt; skelcl = Class.forName(skelname, <span class="literal">false</span>, cl.getClassLoader());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Skeleton)skelcl.newInstance();</span><br><span class="line">    } <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(<span class="string">"Skeleton class not found: "</span> +</span><br><span class="line">                                            skelname, ex);</span><br><span class="line">    } <span class="keyword">catch</span> (InstantiationException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(<span class="string">"Can't create skeleton: "</span> +</span><br><span class="line">                                            skelname, ex);</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalAccessException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(<span class="string">"No public constructor: "</span> +</span><br><span class="line">                                            skelname, ex);</span><br><span class="line">    } <span class="keyword">catch</span> (ClassCastException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(</span><br><span class="line">            <span class="string">"Skeleton not of correct class: "</span> + skelname, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里同样的话是通过反射创建了一个Skeleton</p>
<p>为什么之前创建注册中心的时候没有这一步呢，之前也有提过，在 JDK 1.5 之后，UnicastServerRef内集成了Skeleton的内容，所以在创建远程服务时在创建Stub通过动态代理同时也直接创建好了Skeleton，而创建注册中心时是利用反射创建的，注册中心的源码在JDK 1.5 之前就已经写好了，是不具备Skeleton的，所以这里在创建Stub后需要同时创建一个Skeleton。</p>
<p>之后的流程就和创建远程服务的流程一样，创建一个Target，然后将注册中心发布到网络，最后在ObejctTable对象的一个表中保存注册中心的信息。</p>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry.bind(<span class="string">"remoteObj"</span>,remoteObj);</span><br></pre></td></tr></tbody></table></figure>

<p>直接进去看这个方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String name, Remote obj)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException, AlreadyBoundException, AccessException</span><br><span class="line">{</span><br><span class="line">    checkAccess(<span class="string">"Registry.bind"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (bindings) {</span><br><span class="line">        <span class="type">Remote</span> <span class="variable">curr</span> <span class="operator">=</span> bindings.get(name);</span><br><span class="line">        <span class="keyword">if</span> (curr != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AlreadyBoundException</span>(name);</span><br><span class="line">        bindings.put(name, obj);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先进行一个安全检查（大意是检查调用者是否有权限执行绑定操作），这里无关紧要我们直接跳过，之后从bindings表里面获取一下要绑定的远程对象的name，如果表里面没有，就将远程对象的name和远程对象put到bindings表里面完成绑定。</p>
<h2 id="3-客户端请求注册中心-客户端"><a href="#3-客户端请求注册中心-客户端" class="headerlink" title="3. 客户端请求注册中心-客户端"></a>3. 客户端请求注册中心-客户端</h2><h3 id="客户端创建代理注册中心"><a href="#客户端创建代理注册中心" class="headerlink" title="客户端创建代理注册中心"></a>客户端创建代理注册中心</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">"127.0.0.1"</span>, <span class="number">1099</span>);</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port)</span></span><br><span class="line">	<span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> getRegistry(host, port, <span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port,</span></span><br><span class="line"><span class="params">                                       RMIClientSocketFactory csf)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    {</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span>)</span><br><span class="line">            port = Registry.REGISTRY_PORT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (host == <span class="literal">null</span> || host.length() == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// If host is blank (as returned by "file:" URL in 1.0.2 used in</span></span><br><span class="line">            <span class="comment">// java.rmi.Naming), try to convert to real local host name so</span></span><br><span class="line">            <span class="comment">// that the RegistryImpl's checkAccess will not fail.</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                host = java.net.InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                <span class="comment">// If that failed, at least try "" (localhost) anyway...</span></span><br><span class="line">                host = <span class="string">""</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Create a proxy for the registry with the given host, port, and</span></span><br><span class="line"><span class="comment">         * client socket factory.  If the supplied client socket factory is</span></span><br><span class="line"><span class="comment">         * null, then the ref type is a UnicastRef, otherwise the ref type</span></span><br><span class="line"><span class="comment">         * is a UnicastRef2.  If the property</span></span><br><span class="line"><span class="comment">         * java.rmi.server.ignoreStubClasses is true, then the proxy</span></span><br><span class="line"><span class="comment">         * returned is an instance of a dynamic proxy class that implements</span></span><br><span class="line"><span class="comment">         * the Registry interface; otherwise the proxy returned is an</span></span><br><span class="line"><span class="comment">         * instance of the pregenerated stub class for RegistryImpl.</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="type">LiveRef</span> <span class="variable">liveRef</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LiveRef</span>(<span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.REGISTRY_ID),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(host, port, csf, <span class="literal">null</span>),</span><br><span class="line">                        <span class="literal">false</span>);</span><br><span class="line">        <span class="type">RemoteRef</span> <span class="variable">ref</span> <span class="operator">=</span></span><br><span class="line">            (csf == <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(liveRef) : <span class="keyword">new</span> <span class="title class_">UnicastRef2</span>(liveRef);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Registry) Util.createProxy(RegistryImpl.class, ref, <span class="literal">false</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到这里其实就是创建了一个注册中心，区别在于这里new LiveRef时最后一个参数isLocal变成了false，同时导致后续的几个参数发生了改变，但最后生成的其实还是一个注册中心，只不过此时其从监听远程链接的行为变成了进行远程链接。</p>
<p><strong>这里实质就是创建了一个给定了ip和端口的代理注册中心对象，由于给出了ip和端口这个代理对象包含了如何与远程注册中心通信的所有必要信息，注意这里并没有进行网络活动，只是创建好了一个代理对象，等待后续的操作。</strong></p>
<h3 id="客户端远程调用注册中心获取远程对象"><a href="#客户端远程调用注册中心获取远程对象" class="headerlink" title="客户端远程调用注册中心获取远程对象"></a>客户端远程调用注册中心获取远程对象</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">"remoteObj"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>由于服务端实质是将一个动态代理开放到网络中了，所以这里的操作本质上是获取动态代理并返回</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">lookup</span><span class="params">(String var1)</span> <span class="keyword">throws</span> AccessException, NotBoundException, RemoteException {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">super</span>.ref.newCall(<span class="built_in">this</span>, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">            var3.writeObject(var1);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException var18) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling arguments"</span>, var18);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.ref.invoke(var2);</span><br><span class="line"></span><br><span class="line">        Remote var23;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">ObjectInput</span> <span class="variable">var6</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">            var23 = (Remote)var6.readObject();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException var15) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling return"</span>, var15);</span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException var16) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling return"</span>, var16);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="built_in">super</span>.ref.done(var2);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var23;</span><br><span class="line">    } <span class="keyword">catch</span> (RuntimeException var19) {</span><br><span class="line">        <span class="keyword">throw</span> var19;</span><br><span class="line">    } <span class="keyword">catch</span> (RemoteException var20) {</span><br><span class="line">        <span class="keyword">throw</span> var20;</span><br><span class="line">    } <span class="keyword">catch</span> (NotBoundException var21) {</span><br><span class="line">        <span class="keyword">throw</span> var21;</span><br><span class="line">    } <span class="keyword">catch</span> (Exception var22) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedException</span>(<span class="string">"undeclared checked exception"</span>, var22);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里由于源码的版本是 java1.1 我们的版本是1.8所以无法进行动调，只能静态的看。</p>
<p>这里首先调用了newCall()，这里与注册中心开启了一个连接，通过这个连接传输调用信息。</p>
<p>然后var3.writeObject(var1);将传入的字符串信息序列化后利用创建好的连接传给注册中心，所以注册中心会进行==反序列化==，这里就可以存在漏洞，这里我们到服务端再看。</p>
<p>之后来到super.ref.invoke(var2);，这里的super.ref就是UnicastRef，所以就是UnicastRef.invoke(var2)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(RemoteCall call)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        clientRefLog.log(Log.VERBOSE, <span class="string">"execute call"</span>);</span><br><span class="line"></span><br><span class="line">        call.executeCall();</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (RemoteException e) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Call did not complete; connection can't be reused.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        clientRefLog.log(Log.BRIEF, <span class="string">"exception: "</span>, e);</span><br><span class="line">        free(call, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (Error e) {</span><br><span class="line">        <span class="comment">/* If errors occurred, the connection is most likely not</span></span><br><span class="line"><span class="comment">         *  reusable.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        clientRefLog.log(Log.BRIEF, <span class="string">"error: "</span>, e);</span><br><span class="line">        free(call, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (RuntimeException e) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * REMIND: Since runtime exceptions are no longer wrapped,</span></span><br><span class="line"><span class="comment">         * we can't assue that the connection was left in</span></span><br><span class="line"><span class="comment">         * a reusable state. Is this okay?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        clientRefLog.log(Log.BRIEF, <span class="string">"exception: "</span>, e);</span><br><span class="line">        free(call, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Assume that these other exceptions are user exceptions</span></span><br><span class="line"><span class="comment">         * and leave the connection in a reusable state.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        clientRefLog.log(Log.BRIEF, <span class="string">"exception: "</span>, e);</span><br><span class="line">        free(call, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">/* reraise user (and unknown) exceptions. */</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Don't free the connection if an exception did not</span></span><br><span class="line"><span class="comment">     * occur because the stub needs to unmarshal the</span></span><br><span class="line"><span class="comment">     * return value. The connection will be freed</span></span><br><span class="line"><span class="comment">     * by a call to the "done" method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里主要是call.executeCall();下面都是catch了</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCall</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="type">byte</span> returnType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read result header</span></span><br><span class="line">    <span class="type">DGCAckHandler</span> <span class="variable">ackHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (out != <span class="literal">null</span>) {</span><br><span class="line">            ackHandler = out.getDGCAckHandler();</span><br><span class="line">        }</span><br><span class="line">        releaseOutputStream();</span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">rd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(conn.getInputStream());</span><br><span class="line">        <span class="type">byte</span> <span class="variable">op</span> <span class="operator">=</span> rd.readByte();</span><br><span class="line">        <span class="keyword">if</span> (op != TransportConstants.Return) {</span><br><span class="line">            <span class="keyword">if</span> (Transport.transportLog.isLoggable(Log.BRIEF)) {</span><br><span class="line">                Transport.transportLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">"transport return code invalid: "</span> + op);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"Transport return code invalid"</span>);</span><br><span class="line">        }</span><br><span class="line">        getInputStream();</span><br><span class="line">        returnType = in.readByte();</span><br><span class="line">        in.readID();        <span class="comment">// id for DGC acknowledgement</span></span><br><span class="line">    } <span class="keyword">catch</span> (UnmarshalException e) {</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"Error unmarshaling return header"</span>,</span><br><span class="line">                                     e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (ackHandler != <span class="literal">null</span>) {</span><br><span class="line">            ackHandler.release();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read return value</span></span><br><span class="line">    <span class="keyword">switch</span> (returnType) {</span><br><span class="line">    <span class="keyword">case</span> TransportConstants.NormalReturn:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">        Object ex;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            ex = in.readObject();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"Error unmarshaling return"</span>, e);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// An exception should have been received,</span></span><br><span class="line">        <span class="comment">// if so throw it, else flag error</span></span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> Exception) {</span><br><span class="line">            exceptionReceivedFromServer((Exception) ex);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"Return type not Exception"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Exception is thrown before fallthrough can occur</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (Transport.transportLog.isLoggable(Log.BRIEF)) {</span><br><span class="line">            Transport.transportLog.log(Log.BRIEF,</span><br><span class="line">                <span class="string">"return code invalid: "</span> + returnType);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"Return code invalid"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个方法用来处理返回的数据，主要和网络相关，我们不需要特别深入研究，不过值得注意的是</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (returnType) {</span><br><span class="line"><span class="keyword">case</span> TransportConstants.NormalReturn:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">    Object ex;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        ex = in.readObject();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"Error unmarshaling return"</span>, e);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>这里当产生 TransportConstants.ExceptionalReturn 这个异常时会通过==反序列化==获取网络传输流里面的对象，如果注册中心返回一个恶意对象，即可能产生漏洞。</p>
<p><strong>也就是说，只要存在 super.ref.invoke() 的结构就可能会导致反序列化漏洞产生。</strong></p>
<p>继续往下看lookup方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInput</span> <span class="variable">var6</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">var23 = (Remote)var6.readObject();</span><br></pre></td></tr></tbody></table></figure>

<p>这里==反序列化==了从远程注册中心传回来的输入流，当构造一个恶意的注册中心时可能会导致产生漏洞。</p>
<h2 id="4-客户端请求服务端-客户端"><a href="#4-客户端请求服务端-客户端" class="headerlink" title="4. 客户端请求服务端-客户端"></a>4. 客户端请求服务端-客户端</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remoteObj.sayHello(<span class="string">"hello"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>这里由于得到的remoteObj是一个动态代理，所以会直接调用invoke()</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> Throwable</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (! Proxy.isProxyClass(proxy.getClass())) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"not a proxy"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Proxy.getInvocationHandler(proxy) != <span class="built_in">this</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"handler mismatch"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) {</span><br><span class="line">        <span class="keyword">return</span> invokeObjectMethod(proxy, method, args);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"finalize"</span>.equals(method.getName()) &amp;&amp; method.getParameterCount() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        !allowFinalizeInvocation) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// ignore</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> invokeRemoteMethod(proxy, method, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>前面的if都是安全检查类的东西，直接来看 invokeRemoteMethod(proxy, method, args)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">invokeRemoteMethod</span><span class="params">(Object proxy,</span></span><br><span class="line"><span class="params">                                  Method method,</span></span><br><span class="line"><span class="params">                                  Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (!(proxy <span class="keyword">instanceof</span> Remote)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">"proxy not Remote instance"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ref.invoke((Remote) proxy, method, args,</span><br><span class="line">                          getMethodHash(method));</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> RuntimeException)) {</span><br><span class="line">            Class&lt;?&gt; cl = proxy.getClass();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                method = cl.getMethod(method.getName(),</span><br><span class="line">                                      method.getParameterTypes());</span><br><span class="line">            } <span class="keyword">catch</span> (NoSuchMethodException nsme) {</span><br><span class="line">                <span class="keyword">throw</span> (IllegalArgumentException)</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>().initCause(nsme);</span><br><span class="line">            }</span><br><span class="line">            Class&lt;?&gt; thrownType = e.getClass();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; declaredType : method.getExceptionTypes()) {</span><br><span class="line">                <span class="keyword">if</span> (declaredType.isAssignableFrom(thrownType)) {</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            e = <span class="keyword">new</span> <span class="title class_">UnexpectedException</span>(<span class="string">"unexpected exception"</span>, e);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里同样会走一个UnicastRef.invoke()，不过由于参数不同此处并不是上述的那个invoke方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Remote obj,</span></span><br><span class="line"><span class="params">                     Method method,</span></span><br><span class="line"><span class="params">                     Object[] params,</span></span><br><span class="line"><span class="params">                     <span class="type">long</span> opnum)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (clientRefLog.isLoggable(Log.VERBOSE)) {</span><br><span class="line">        clientRefLog.log(Log.VERBOSE, <span class="string">"method: "</span> + method);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clientCallLog.isLoggable(Log.VERBOSE)) {</span><br><span class="line">        logClientCall(obj, method);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ref.getChannel().newConnection();</span><br><span class="line">    <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">reuse</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the call connection is "reused" early, remember not to</span></span><br><span class="line"><span class="comment">     * reuse again.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">alreadyFreed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (clientRefLog.isLoggable(Log.VERBOSE)) {</span><br><span class="line">            clientRefLog.log(Log.VERBOSE, <span class="string">"opnum = "</span> + opnum);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create call context</span></span><br><span class="line">        call = <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn, ref.getObjID(), -<span class="number">1</span>, opnum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// marshal parameters</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">            marshalCustomCallData(out);</span><br><span class="line">            Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) {</span><br><span class="line">                marshalValue(types[i], params[i], out);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            clientRefLog.log(Log.BRIEF,</span><br><span class="line">                <span class="string">"IOException marshalling arguments: "</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling arguments"</span>, e);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// unmarshal return</span></span><br><span class="line">        call.executeCall();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Class&lt;?&gt; rtype = method.getReturnType();</span><br><span class="line">            <span class="keyword">if</span> (rtype == <span class="keyword">void</span>.class)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* StreamRemoteCall.done() does not actually make use</span></span><br><span class="line"><span class="comment">             * of conn, therefore it is safe to reuse this</span></span><br><span class="line"><span class="comment">             * connection before the dirty call is sent for</span></span><br><span class="line"><span class="comment">             * registered refs.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> unmarshalValue(rtype, in);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* we are freeing the connection now, do not free</span></span><br><span class="line"><span class="comment">             * again or reuse.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            alreadyFreed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* if we got to this point, reuse must have been true. */</span></span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">"free connection (reuse = true)"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Free the call's connection early. */</span></span><br><span class="line">            ref.getChannel().free(conn, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> returnValue;</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            clientRefLog.log(Log.BRIEF,</span><br><span class="line">                             <span class="string">"IOException unmarshalling return: "</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling return"</span>, e);</span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">            clientRefLog.log(Log.BRIEF,</span><br><span class="line">                <span class="string">"ClassNotFoundException unmarshalling return: "</span>, e);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling return"</span>, e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                call.done();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                <span class="comment">/* WARNING: If the conn has been reused early,</span></span><br><span class="line"><span class="comment">                 * then it is too late to recover from thrown</span></span><br><span class="line"><span class="comment">                 * IOExceptions caught here. This code is relying</span></span><br><span class="line"><span class="comment">                 * on StreamRemoteCall.done() not actually</span></span><br><span class="line"><span class="comment">                 * throwing IOExceptions.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                reuse = <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (RuntimeException e) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Need to distinguish between client (generated by the</span></span><br><span class="line"><span class="comment">         * invoke method itself) and server RuntimeExceptions.</span></span><br><span class="line"><span class="comment">         * Client side RuntimeExceptions are likely to have</span></span><br><span class="line"><span class="comment">         * corrupted the call connection and those from the server</span></span><br><span class="line"><span class="comment">         * are not likely to have done so.  If the exception came</span></span><br><span class="line"><span class="comment">         * from the server the call connection should be reused.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((call == <span class="literal">null</span>) ||</span><br><span class="line">            (((StreamRemoteCall) call).getServerException() != e))</span><br><span class="line">        {</span><br><span class="line">            reuse = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (RemoteException e) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Some failure during call; assume connection cannot</span></span><br><span class="line"><span class="comment">         * be reused.  Must assume failure even if ServerException</span></span><br><span class="line"><span class="comment">         * or ServerError occurs since these failures can happen</span></span><br><span class="line"><span class="comment">         * during parameter deserialization which would leave</span></span><br><span class="line"><span class="comment">         * the connection in a corrupted state.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        reuse = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (Error e) {</span><br><span class="line">        <span class="comment">/* If errors occurred, the connection is most likely not</span></span><br><span class="line"><span class="comment">         *  reusable.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        reuse = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* alreadyFreed ensures that we do not log a reuse that</span></span><br><span class="line"><span class="comment">         * may have already happened.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!alreadyFreed) {</span><br><span class="line">            <span class="keyword">if</span> (clientRefLog.isLoggable(Log.BRIEF)) {</span><br><span class="line">                clientRefLog.log(Log.BRIEF, <span class="string">"free connection (reuse = "</span> +</span><br><span class="line">                                       reuse + <span class="string">")"</span>);</span><br><span class="line">            }</span><br><span class="line">            ref.getChannel().free(conn, reuse);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里代码有点庞大，我们挑主要的看</p>
<p>首先是会调用一个</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">marshalValue(types[i], params[i], out);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">marshalValue</span><span class="params">(Class&lt;?&gt; type, Object value,</span></span><br><span class="line"><span class="params">                                      ObjectOutput out)</span></span><br><span class="line">       <span class="keyword">throws</span> IOException</span><br><span class="line">   {</span><br><span class="line">       <span class="keyword">if</span> (type.isPrimitive()) {</span><br><span class="line">           <span class="keyword">if</span> (type == <span class="type">int</span>.class) {</span><br><span class="line">               out.writeInt(((Integer) value).intValue());</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">boolean</span>.class) {</span><br><span class="line">               out.writeBoolean(((Boolean) value).booleanValue());</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">byte</span>.class) {</span><br><span class="line">               out.writeByte(((Byte) value).byteValue());</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">char</span>.class) {</span><br><span class="line">               out.writeChar(((Character) value).charValue());</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">short</span>.class) {</span><br><span class="line">               out.writeShort(((Short) value).shortValue());</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">long</span>.class) {</span><br><span class="line">               out.writeLong(((Long) value).longValue());</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">float</span>.class) {</span><br><span class="line">               out.writeFloat(((Float) value).floatValue());</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">double</span>.class) {</span><br><span class="line">               out.writeDouble(((Double) value).doubleValue());</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"Unrecognized primitive type: "</span> + type);</span><br><span class="line">           }</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">           out.writeObject(value);</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<p>这里大意的话就是把我们远程调用方法时传入的参数传给服务端，如果不是基础的类型的话就会使用==序列化==传</p>
<p>然后继续往下走会调用一个 call.executeCall(); 这个就是之前获取注册中心远程对象时的那个危险方法，也会导致反序列化</p>
<p>继续往下看</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> unmarshalValue(rtype, in);</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title function_">unmarshalValue</span><span class="params">(Class&lt;?&gt; type, ObjectInput in)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (type.isPrimitive()) {</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="type">int</span>.class) {</span><br><span class="line">                <span class="keyword">return</span> Integer.valueOf(in.readInt());</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">boolean</span>.class) {</span><br><span class="line">                <span class="keyword">return</span> Boolean.valueOf(in.readBoolean());</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">byte</span>.class) {</span><br><span class="line">                <span class="keyword">return</span> Byte.valueOf(in.readByte());</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">char</span>.class) {</span><br><span class="line">                <span class="keyword">return</span> Character.valueOf(in.readChar());</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">short</span>.class) {</span><br><span class="line">                <span class="keyword">return</span> Short.valueOf(in.readShort());</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">long</span>.class) {</span><br><span class="line">                <span class="keyword">return</span> Long.valueOf(in.readLong());</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">float</span>.class) {</span><br><span class="line">                <span class="keyword">return</span> Float.valueOf(in.readFloat());</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">double</span>.class) {</span><br><span class="line">                <span class="keyword">return</span> Double.valueOf(in.readDouble());</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"Unrecognized primitive type: "</span> + type);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> in.readObject();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>这里是读取从服务端传回的内容，这里如果有一个恶意的远程对象也会受==反序列化==攻击。</p>
<h3 id="JRMP攻击"><a href="#JRMP攻击" class="headerlink" title="JRMP攻击"></a><strong>JRMP攻击</strong></h3><p>executeCall()方法执行的就是JRMP协议，所以常说的JRMP攻击其实就是此处产生的</p>
<h2 id="5-客户端请求注册中心-注册中心"><a href="#5-客户端请求注册中心-注册中心" class="headerlink" title="5. 客户端请求注册中心-注册中心"></a>5. 客户端请求注册中心-注册中心</h2><p>这里我们跟一个调用链一直走：</p>
<p>LocateRegistry.createRegistry() -&gt;  RegistryImpl() -&gt; setup() -&gt; UnicastServerRef.exportObject() -&gt; UnicastServerRef.exportObject() -&gt; LiveRef.exportObject() -&gt; TCPEndpoint.exportObject() -&gt; listen() -&gt; AcceptLoop() -&gt; run() -&gt; executeAcceptLoop() -&gt; ConnectionHandler() -&gt; run() -&gt; run0() -&gt; handleMessages() -&gt; serviceCall()</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">serviceCall</span><span class="params">(<span class="keyword">final</span> RemoteCall call)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">/* read object id */</span></span><br><span class="line">        <span class="keyword">final</span> Remote impl;</span><br><span class="line">        ObjID id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            id = ObjID.read(call.getInputStream());</span><br><span class="line">        } <span class="keyword">catch</span> (java.io.IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"unable to read objID"</span>, e);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get the remote object */</span></span><br><span class="line">        <span class="type">Transport</span> <span class="variable">transport</span> <span class="operator">=</span> id.equals(dgcID) ? <span class="literal">null</span> : <span class="built_in">this</span>;</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">            ObjectTable.getTarget(<span class="keyword">new</span> <span class="title class_">ObjectEndpoint</span>(id, transport));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span> || (impl = target.getImpl()) == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchObjectException</span>(<span class="string">"no such object in table"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Dispatcher</span> <span class="variable">disp</span> <span class="operator">=</span> target.getDispatcher();</span><br><span class="line">        target.incrementCallCount();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">/* call the dispatcher */</span></span><br><span class="line">            transportLog.log(Log.VERBOSE, <span class="string">"call dispatcher"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span></span><br><span class="line">                target.getAccessControlContext();</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">ccl</span> <span class="operator">=</span> target.getContextClassLoader();</span><br><span class="line"></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">savedCcl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                setContextClassLoader(ccl);</span><br><span class="line">                currentTransport.set(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    java.security.AccessController.doPrivileged(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedExceptionAction&lt;Void&gt;() {</span><br><span class="line">                        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">                            checkAcceptPermission(acc);</span><br><span class="line">                            disp.dispatch(impl, call);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }, acc);</span><br><span class="line">                } <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) {</span><br><span class="line">                    <span class="keyword">throw</span> (IOException) pae.getException();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                setContextClassLoader(savedCcl);</span><br><span class="line">                currentTransport.set(<span class="literal">null</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">            transportLog.log(Log.BRIEF,</span><br><span class="line">                             <span class="string">"exception thrown by dispatcher: "</span>, ex);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            target.decrementCallCount();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (RemoteException e) {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if calls are being logged, write out exception</span></span><br><span class="line">        <span class="keyword">if</span> (UnicastServerRef.callLog.isLoggable(Log.BRIEF)) {</span><br><span class="line">            <span class="comment">// include client host name if possible</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">clientHost</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                clientHost = <span class="string">"["</span> +</span><br><span class="line">                    RemoteServer.getClientHost() + <span class="string">"] "</span>;</span><br><span class="line">            } <span class="keyword">catch</span> (ServerNotActiveException ex) {</span><br><span class="line">            }</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> clientHost + <span class="string">"exception: "</span>;</span><br><span class="line">            UnicastServerRef.callLog.log(Log.BRIEF, message, e);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We will get a RemoteException if either a) the objID is</span></span><br><span class="line"><span class="comment">         * not readable, b) the target is not in the object table, or</span></span><br><span class="line"><span class="comment">         * c) the object is in the midst of being unexported (note:</span></span><br><span class="line"><span class="comment">         * NoSuchObjectException is thrown by the incrementCallCount</span></span><br><span class="line"><span class="comment">         * method if the object is being unexported).  Here it is</span></span><br><span class="line"><span class="comment">         * relatively safe to marshal an exception to the client</span></span><br><span class="line"><span class="comment">         * since the client will not have seen a return value yet.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">false</span>);</span><br><span class="line">            UnicastServerRef.clearStackTraces(e);</span><br><span class="line">            out.writeObject(e);</span><br><span class="line">            call.releaseOutputStream();</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (IOException ie) {</span><br><span class="line">            transportLog.log(Log.BRIEF,</span><br><span class="line">                <span class="string">"exception thrown marshalling exception: "</span>, ie);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里serviceCall 方法是 Java 框架中服务端用于处理客户端远程调用请求的核心方法，他主要有如下作用：</p>
<blockquote>
<ol>
<li>读取客户端请求中的对象ID（ObjID）。</li>
<li>查找并获取对应的远程对象（Remote Object）。</li>
<li>调用该对象的分发器（Dispatcher）来实际执行远程方法。</li>
<li>处理调用过程中的各种异常，并将异常信息返回给客户。</li>
</ol>
</blockquote>
<p>这里我们主要看</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disp.dispatch(impl, call);</span><br></pre></td></tr></tbody></table></figure>

<p>这里的disp是UnicastServerRef</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote obj, RemoteCall call)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="comment">// positive operation number in 1.1 stubs;</span></span><br><span class="line">        <span class="comment">// negative version number in 1.2 stubs and beyond...</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">long</span> op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// read remote call header</span></span><br><span class="line">            ObjectInput in;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                in = call.getInputStream();</span><br><span class="line">                num = in.readInt();</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (skel != <span class="literal">null</span>) {</span><br><span class="line">                        oldDispatch(obj, call, num);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">                            <span class="string">"skeleton class not found but required "</span> +</span><br><span class="line">                            <span class="string">"for client version"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                op = in.readLong();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception readEx) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling call header"</span>,</span><br><span class="line">                                             readEx);</span><br><span class="line">            }</span><br><span class="line">            ......</span><br></pre></td></tr></tbody></table></figure>

<p>这里会走到一个oldDispatch()方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldDispatch</span><span class="params">(Remote obj, RemoteCall call, <span class="type">int</span> op)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">{</span><br><span class="line">    <span class="type">long</span> hash;              <span class="comment">// hash for matching stub with skeleton</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// read remote call header</span></span><br><span class="line">        ObjectInput in;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            in = call.getInputStream();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(<span class="string">"sun.rmi.transport.DGCImpl_Skel"</span>);</span><br><span class="line">                <span class="keyword">if</span> (clazz.isAssignableFrom(skel.getClass())) {</span><br><span class="line">                    ((MarshalInputStream)in).useCodebaseOnly();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (ClassNotFoundException ignore) { }</span><br><span class="line">            hash = in.readLong();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception readEx) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling call header"</span>,</span><br><span class="line">                                         readEx);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if calls are being logged, write out object id and operation</span></span><br><span class="line">        logCall(obj, skel.getOperations()[op]);</span><br><span class="line">        unmarshalCustomCallData(in);</span><br><span class="line">        <span class="comment">// dispatch to skeleton for remote object</span></span><br><span class="line">        skel.dispatch(obj, call, op, hash);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">        logCallException(e);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Error) {</span><br><span class="line">            e = <span class="keyword">new</span> <span class="title class_">ServerError</span>(</span><br><span class="line">                <span class="string">"Error occurred in server thread"</span>, (Error) e);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RemoteException) {</span><br><span class="line">            e = <span class="keyword">new</span> <span class="title class_">ServerException</span>(</span><br><span class="line">                <span class="string">"RemoteException occurred in server thread"</span>,</span><br><span class="line">                (Exception) e);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (suppressStackTraces) {</span><br><span class="line">            clearStackTraces(e);</span><br><span class="line">        }</span><br><span class="line">        out.writeObject(e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        call.releaseInputStream(); <span class="comment">// in case skeleton doesn't</span></span><br><span class="line">        call.releaseOutputStream();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里会执行：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skel.dispatch(obj, call, op, hash);</span><br></pre></td></tr></tbody></table></figure>

<p>到这里终于走到了我们的核心类 注册中心的dispatch：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote var1, RemoteCall var2, <span class="type">int</span> var3, <span class="type">long</span> var4)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">if</span> (var4 != <span class="number">4905912898345647071L</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonMismatchException</span>(<span class="string">"interface hash mismatch"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">RegistryImpl</span> <span class="variable">var6</span> <span class="operator">=</span> (RegistryImpl)var1;</span><br><span class="line">            String var7;</span><br><span class="line">            Remote var8;</span><br><span class="line">            ObjectInput var10;</span><br><span class="line">            ObjectInput var11;</span><br><span class="line">            <span class="keyword">switch</span> (var3) {</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        var11 = var2.getInputStream();</span><br><span class="line">                        var7 = (String)var11.readObject();</span><br><span class="line">                        var8 = (Remote)var11.readObject();</span><br><span class="line">                    } <span class="keyword">catch</span> (IOException var94) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var94);</span><br><span class="line">                    } <span class="keyword">catch</span> (ClassNotFoundException var95) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var95);</span><br><span class="line">                    } <span class="keyword">finally</span> {</span><br><span class="line">                        var2.releaseInputStream();</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    var6.bind(var7, var8);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    } <span class="keyword">catch</span> (IOException var93) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, var93);</span><br><span class="line">                    }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                    String[] var97 = var6.list();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="type">ObjectOutput</span> <span class="variable">var98</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                        var98.writeObject(var97);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    } <span class="keyword">catch</span> (IOException var92) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, var92);</span><br><span class="line">                    }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        var10 = var2.getInputStream();</span><br><span class="line">                        var7 = (String)var10.readObject();</span><br><span class="line">                    } <span class="keyword">catch</span> (IOException var89) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var89);</span><br><span class="line">                    } <span class="keyword">catch</span> (ClassNotFoundException var90) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var90);</span><br><span class="line">                    } <span class="keyword">finally</span> {</span><br><span class="line">                        var2.releaseInputStream();</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    var8 = var6.lookup(var7);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="type">ObjectOutput</span> <span class="variable">var9</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                        var9.writeObject(var8);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    } <span class="keyword">catch</span> (IOException var88) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, var88);</span><br><span class="line">                    }</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure>

<p>这里的这个case2中存在一个readObject，其原本的作用是用来处理来自客户端</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">"remoteObj"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>处的字符串，从安全的角度出发这里也可能存在反序列化漏洞</p>
<h2 id="6-客户端请求服务端-服务端"><a href="#6-客户端请求服务端-服务端" class="headerlink" title="6. 客户端请求服务端-服务端"></a>6. 客户端请求服务端-服务端</h2><p>这里前半部分和上一环节中的内容一模一样，到 UnicastServerRef.dispatch() 方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote obj, RemoteCall call)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="comment">// positive operation number in 1.1 stubs;</span></span><br><span class="line">        <span class="comment">// negative version number in 1.2 stubs and beyond...</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">long</span> op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// read remote call header</span></span><br><span class="line">            ObjectInput in;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                in = call.getInputStream();</span><br><span class="line">                num = in.readInt();</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (skel != <span class="literal">null</span>) {</span><br><span class="line">                        oldDispatch(obj, call, num);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">                            <span class="string">"skeleton class not found but required "</span> +</span><br><span class="line">                            <span class="string">"for client version"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                op = in.readLong();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception readEx) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling call header"</span>,</span><br><span class="line">                                             readEx);</span><br><span class="line">            }</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                unmarshalCustomCallData(in);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) {</span><br><span class="line">                    params[i] = unmarshalValue(types[i], in);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (java.io.IOException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">                    <span class="string">"error unmarshalling arguments"</span>, e);</span><br><span class="line">            } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">                    <span class="string">"error unmarshalling arguments"</span>, e);</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                call.releaseInputStream();</span><br><span class="line">            }</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure>

<p>这里由于skel是空所以会继续往下走，到</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params[i] = unmarshalValue(types[i], in);</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title function_">unmarshalValue</span><span class="params">(Class&lt;?&gt; type, ObjectInput in)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (type.isPrimitive()) {</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="type">int</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Integer.valueOf(in.readInt());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">boolean</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Boolean.valueOf(in.readBoolean());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">byte</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Byte.valueOf(in.readByte());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">char</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Character.valueOf(in.readChar());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">short</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Short.valueOf(in.readShort());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">long</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Long.valueOf(in.readLong());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">float</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Float.valueOf(in.readFloat());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">double</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Double.valueOf(in.readDouble());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"Unrecognized primitive type: "</span> + type);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> in.readObject();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里主要是处理客户端的这句代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remoteObj.sayHello(<span class="string">"hello"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>将客户端传来的这个参数反序列化读出，由于使用了readObject() 方法，这里也会导致产生反序列化漏洞。</p>
<h2 id="7-DGC垃圾回收"><a href="#7-DGC垃圾回收" class="headerlink" title="7. DGC垃圾回收"></a>7. DGC垃圾回收</h2><p>在一开始我们创建远程对象的最后</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putTarget</span><span class="params">(Target target)</span> <span class="keyword">throws</span> ExportException {</span><br><span class="line">    <span class="type">ObjectEndpoint</span> <span class="variable">oe</span> <span class="operator">=</span> target.getObjectEndpoint();</span><br><span class="line">    <span class="type">WeakRef</span> <span class="variable">weakImpl</span> <span class="operator">=</span> target.getWeakImpl();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DGCImpl.dgcLog.isLoggable(Log.VERBOSE)) {</span><br><span class="line">        DGCImpl.dgcLog.log(Log.VERBOSE, <span class="string">"add object "</span> + oe);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (tableLock) {</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Do nothing if impl has already been collected (see 6597112). Check while</span></span><br><span class="line"><span class="comment">         * holding tableLock to ensure that Reaper cannot process weakImpl in between</span></span><br><span class="line"><span class="comment">         * null check and put/increment effects.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (target.getImpl() != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (objTable.containsKey(oe)) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">                    <span class="string">"internal error: ObjID already in use"</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (implTable.containsKey(weakImpl)) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">"object already exported"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            objTable.put(oe, target);</span><br><span class="line">            implTable.put(weakImpl, target);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!target.isPermanent()) {</span><br><span class="line">                incrementKeepAliveCount();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一开头会执行一个if，这里其实会创建一个和远程服务结构类似的DGC，由于调用的是DGCImpl.dgcLog的方法，是一个静态属性，参考java类加载机制进行类的初始化，这里会执行DGCImpl的静态代码块。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * "Export" the singleton DGCImpl in a context isolated from</span></span><br><span class="line"><span class="comment">         * the arbitrary current thread context.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() {</span><br><span class="line">            <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">savedCcl</span> <span class="operator">=</span></span><br><span class="line">                    Thread.currentThread().getContextClassLoader();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.currentThread().setContextClassLoader(</span><br><span class="line">                        ClassLoader.getSystemClassLoader());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Put remote collector object in table by hand to prevent</span></span><br><span class="line"><span class="comment">                     * listen on port.  (UnicastServerRef.exportObject would</span></span><br><span class="line"><span class="comment">                     * cause transport to listen.)</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        dgc = <span class="keyword">new</span> <span class="title class_">DGCImpl</span>();</span><br><span class="line">                        <span class="type">ObjID</span> <span class="variable">dgcID</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.DGC_ID);</span><br><span class="line">                        <span class="type">LiveRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(dgcID, <span class="number">0</span>);</span><br><span class="line">                        <span class="type">UnicastServerRef</span> <span class="variable">disp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(ref);</span><br><span class="line">                        <span class="type">Remote</span> <span class="variable">stub</span> <span class="operator">=</span></span><br><span class="line">                            Util.createProxy(DGCImpl.class,</span><br><span class="line">                                             <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(ref), <span class="literal">true</span>);</span><br><span class="line">                        disp.setSkeleton(dgc);</span><br><span class="line"></span><br><span class="line">                        <span class="type">Permissions</span> <span class="variable">perms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Permissions</span>();</span><br><span class="line">                        perms.add(<span class="keyword">new</span> <span class="title class_">SocketPermission</span>(<span class="string">"*"</span>, <span class="string">"accept,resolve"</span>));</span><br><span class="line">                        ProtectionDomain[] pd = { <span class="keyword">new</span> <span class="title class_">ProtectionDomain</span>(<span class="literal">null</span>, perms) };</span><br><span class="line">                        <span class="type">AccessControlContext</span> <span class="variable">acceptAcc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccessControlContext</span>(pd);</span><br><span class="line"></span><br><span class="line">                        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Target&gt;() {</span><br><span class="line">                                <span class="keyword">public</span> Target <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Target</span>(dgc, disp, stub, dgcID, <span class="literal">true</span>);</span><br><span class="line">                                }</span><br><span class="line">                            }, acceptAcc);</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure>

<p>这里有点类似于注册中心那里Util.createProxy(DGCImpl.class,new UnicastRef(ref), true);-&gt;stubClassExists(remoteClass)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">stubClassExists</span><span class="params">(Class&lt;?&gt; remoteClass)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!withoutStubs.containsKey(remoteClass)) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Class.forName(remoteClass.getName() + <span class="string">"_Stub"</span>,</span><br><span class="line">                          <span class="literal">false</span>,</span><br><span class="line">                          remoteClass.getClassLoader());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException cnfe) {</span><br><span class="line">            withoutStubs.put(remoteClass, <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里会去找一个DGCImpl_Stub.class，其中也会调用 super.ref.invoke() 同客户端请求服务端-客户端那里一样，所以此处也会导致<strong>JRMP攻击</strong>，还有</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.ref.invoke(var5);</span><br><span class="line"></span><br><span class="line">            Lease var24;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">ObjectInput</span> <span class="variable">var9</span> <span class="operator">=</span> var5.getInputStream();</span><br><span class="line">                var24 = (Lease)var9.readObject();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException var17) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling return"</span>, var17);</span><br><span class="line">            } <span class="keyword">catch</span> (ClassNotFoundException var18) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling return"</span>, var18);</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="built_in">super</span>.ref.done(var5);</span><br><span class="line">            }</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure>

<p>这里的try里面也会执行一个readObject()所以也可能会受到反序列化攻击。所以DCC客户端同样可能会受到反序列化攻击，同样DGC也存在skel</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote var1, RemoteCall var2, <span class="type">int</span> var3, <span class="type">long</span> var4)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">if</span> (var4 != -<span class="number">669196253586618813L</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonMismatchException</span>(<span class="string">"interface hash mismatch"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">DGCImpl</span> <span class="variable">var6</span> <span class="operator">=</span> (DGCImpl)var1;</span><br><span class="line">            ObjID[] var7;</span><br><span class="line">            <span class="type">long</span> var8;</span><br><span class="line">            <span class="keyword">switch</span> (var3) {</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    VMID var39;</span><br><span class="line">                    <span class="type">boolean</span> var40;</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="type">ObjectInput</span> <span class="variable">var14</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">                        var7 = (ObjID[])var14.readObject();</span><br><span class="line">                        var8 = var14.readLong();</span><br><span class="line">                        var39 = (VMID)var14.readObject();</span><br><span class="line">                        var40 = var14.readBoolean();</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure>

<p>这里同样有许多的 readObject() 方法，因此DGC的服务端同样也存在反序列化漏洞攻击点。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">ShaGou</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/25/RMI%E5%9F%BA%E7%A1%80/">http://example.com/2025/03/25/RMI%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">ShaGou's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RMI/">RMI</a></div><div class="post-share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/03/14/Shiro550/" title="Shiro550"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Shiro550</div></div><div class="info-2"><div class="info-item-1">环境搭建https://github.com/sanjiu176/Shiro-root-1.2.4.git 入口点分析：CookieRememberMeManager.getRememberedSerializedIdentity()12345678910111213141516171819202122232425262728293031323334353637383940protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) {    if (!WebUtils.isHttp(subjectContext)) {        if (log.isDebugEnabled()) {            String msg = "SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a " +          ...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info-name">ShaGou</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sanjiu176"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RMI%E7%AE%80%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">RMI简述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84RMI%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.</span> <span class="toc-text">一个简单的RMI实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RMIServer"><span class="toc-number">1.1.1.</span> <span class="toc-text">RMIServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RMIClient"><span class="toc-number">1.1.2.</span> <span class="toc-text">RMIClient</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.</span> <span class="toc-text">1.服务端创建远程服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UnicastServerRef"><span class="toc-number">2.1.1.</span> <span class="toc-text">UnicastServerRef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exportObject"><span class="toc-number">2.1.2.</span> <span class="toc-text">exportObject()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%9B%E5%BB%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-%E7%BB%91%E5%AE%9A"><span class="toc-number">2.2.</span> <span class="toc-text">2. 服务端创建注册中心+绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">2.2.1.</span> <span class="toc-text">创建注册中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A"><span class="toc-number">2.2.2.</span> <span class="toc-text">绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.3.</span> <span class="toc-text">3. 客户端请求注册中心-客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">2.3.1.</span> <span class="toc-text">客户端创建代理注册中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%8E%B7%E5%8F%96%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.2.</span> <span class="toc-text">客户端远程调用注册中心获取远程对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.4.</span> <span class="toc-text">4. 客户端请求服务端-客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JRMP%E6%94%BB%E5%87%BB"><span class="toc-number">2.4.1.</span> <span class="toc-text">JRMP攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">2.5.</span> <span class="toc-text">5. 客户端请求注册中心-注册中心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">2.6.</span> <span class="toc-text">6. 客户端请求服务端-服务端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-DGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.7.</span> <span class="toc-text">7. DGC垃圾回收</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/25/RMI%E5%9F%BA%E7%A1%80/" title="RMI基础">RMI基础</a><time datetime="2025-03-25T12:53:01.000Z" title="发表于 2025-03-25 20:53:01">2025-03-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/14/Shiro550/" title="Shiro550">Shiro550</a><time datetime="2025-03-14T06:05:38.000Z" title="发表于 2025-03-14 14:05:38">2025-03-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/05/CC7/" title="CC7">CC7</a><time datetime="2025-03-05T09:06:59.000Z" title="发表于 2025-03-05 17:06:59">2025-03-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/04/CC5/" title="CC5">CC5</a><time datetime="2025-03-04T11:25:15.000Z" title="发表于 2025-03-04 19:25:15">2025-03-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/04/CC2/" title="CC2">CC2</a><time datetime="2025-03-04T09:43:36.000Z" title="发表于 2025-03-04 17:43:36">2025-03-04</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">©2019 - 2025 By ShaGou</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>